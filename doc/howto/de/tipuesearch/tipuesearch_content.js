var tipuesearch = {"pages": [

{"title": "<h1 class='page-title-lvl-cover' id='Bookmark1'>How-To CentraXX: CentraXX FHIR Custom Export</h1>", "text": "TitelCentraXX FHIR Custom ExportErstellerJonas K&uuml;ttner, Mike W&auml;hnert Datum2021-02-22Version1.9StatusFinalVerbleibZu Schulungszwecken externe Weitergabe erlaubt.VerlaufVersionBeschreibungBearbeiter2020-12-140.1Vorlagen und AgendaMike W&auml;hnert2021-01-040.2Initialer EntwurfJonas K&uuml;ttner2021-01-120.3KorrekturenMike W&auml;hnert2021-01-120.4Kleine KorrekturenJonas K&uuml;ttner2021-01-140.5Configs f\u00FCr TLS/SSLUmfang, Zielgruppe, ScopeUML-DiagrammAusleitung in BlazeJonas K&uuml;ttner2021-01-160.6Ausleitung-Filesystemallgemeine \u00DCberarbeitungJonas K&uuml;ttner2021-01-181.0KorrekturenInitialer ReleaseMike W&auml;hnert2021-01-211.1Finale KorrekturenJovana Radlovic2021-02-051.2Update Installation des Beispiel Projekts von GitHubJonas K&uuml;ttner2021-02-111.3Update der Installation der Kairos-FHIR-DSL-Bibliothek \u00FCber GitHub, Erl\u00E4uterung Code-Completion f\u00FCr JPA-Model, Ersetzung der Strings zu Meta-Model-Methoden in Beispielen, Neuerung der ScreenshotsJonas K&uuml;ttner2021-02-121.4Versionsnummer DSL und IntelliJ aktualisiert.Jonas K&uuml;ttner2021-02-121.5KorrekturenMike W&auml;hnert2021-02-121.6Korrekturen, Erweiterung JPA-NavigationJonas K&uuml;ttner2021-02-181.7Korrekturen, \u00C4nderung der Beschreibung der Installation des example-Projekts auf Nutzung des Latest Release.Unn\u00F6tiges Code-Snippet entferntJonas K&uuml;ttner2021-02-181.8Einf\u00FChrung des inkrementellen TransportsAnpassung von Pfaden und Bezeichnungen von nfn zu fhir-customJonas K&uuml;ttner2021-02-221.9Korrekturen + Einf\u00FCgen von Referenzen und QuellenDennis SpiegelVersionierungVersionDatumBearbeiter/inDateiKommentar1.92021-02-22Mike W\u00E4hnertCXX_FHIR_Custom_Export.pdf1.92021-02-22Mike W\u00E4hnertCXX_FHIR_Custom_Export.doc                \n            \n                Inhaltsverzeichnis\n\n1 Versionierung\n2 Inhaltsverzeichnis\n3 Abk\u00FCrzungsverzeichnis\n4 Einleitung\n\n4.1 Inhalt des Dokuments\n4.2 Zielgruppe\n4.3 \u00DCberblick \u00FCber die Schnittstelle\n\n4.3.1 Scheduled Export:\n4.3.2 Inkrementeller Export:\n\n\n\n\n5 Einrichtung in CentraXX\n\n5.1 Konfiguration der centraxx-dev.properties\n5.2 Einrichtung eines Projekts am Beispiel einer Ausleitung f\u00FCr das DKTK\n\n5.2.1 ProjectConfig.json\n5.2.2 ExportResourceMappingConfig.json\n5.2.3 ResourceBundleExportConfig.json\n\n\n\n\n6 Nutzung der Groovy-DSL-Bibliothek\n\n6.1 Einleitung/\u00DCberblick\n6.2 Voraussetzungen zur Nutzung der Kairos-FHIR-DSL Bibliothek und des Beispielprojekts\n6.3 Installation des FHIR-Beispielprojekts\n6.4 Installation der FHIR-DSL-Bibliothek\n6.5 Verwendung der DSL-Bibliothek zur Erstellung von Transformations-Skripten\n\n6.5.1 Allgemeines\n6.5.2 Zusammenbau der FHIR Nachricht mit Groovy Closures\n6.5.3 CXX JPA Meta Model und die Verwendung von context.source mit der JPA-Navigation\n\n6.5.3.1 JPA Meta Model\n6.5.3.2 Navigation mittels verketteter Methodenaufrufe\n6.5.3.3 Verwendung von Konstanten in Listen-Closures\n\n\n6.5.4 Definition eigener Methoden, um CentraXX-Entit\u00E4ten optimal abzubilden\n\n\n\n\n7 FHIR-Export in Zielsysteme\n\n7.1 Ausleitung in einen Blaze Store\n7.2 Ausleitung ins Dateisystem\n\n\n8 Anhang\n\n8.1 Beispiel f\u00FCr ausgeleitetes FHIR-Bundle f\u00FCr die FHIR-Ressource &quot;Patient&quot;\n\n\n\n                \n            \n                Abk\u00FCrzungsverzeichnisCXXCentraXX, siehe\u00A0https://www.kairos.deFHIRFast Healthcare Interoperability Resources, siehe https://hl7.org/FHIR/DSLDomain-specific languageJPAJava Persistence APIDKTKDeutsches Konsortium f\u00FCr Translationale Krebsforschung (https://dktk.dkfz.de/de/home\u00A0/\u00A0https://simplifier.net/oncology)BBMRIBiobanking and Biomolecular Resources Research Infrastructure, siehe https://www.bbmri.de/ueber-gbn/bbmri-eric/                \n            \n                EinleitungInhalt des DokumentsDie vorliegende Dokumentation des CentraXX-FHIR-Custom-Exports umfasst folgende Punkte:initiale Einrichtung der Schnittstelle f\u00FCr den CentraXX-FHIR-Custom-ExportKonfiguration des Exports f\u00FCr spezifische FHIR-ProjekteEinrichtung einer Entwicklungsumgebung und Installation einer Groovy-basierten Kairos-FHIR-DSL-BibliothekExemplarische Einf\u00FChrung in die Funktionalit\u00E4t der DSL als Grundlage zur Erarbeitung eigener Transformationsskripte.Zur Einf\u00FChrung in die Nutzung der DSL werden Code-Beispiele aus bereits existierenden Beispiel-Transformationsskripten herangezogen. Dabei wird kontextuell auf die Programmiersprache 'Groovy' eingegangen, das vorliegende Dokument\u00A0dient jedoch nicht dazu Grundlagen von Groovy, Prinzipien der Implementation der DSL oder die Spezifikation des HL7-FHIR-Standard zu vermitteln. An geeigneten Stellen werden weiterf\u00FChrende Links zu den eben genannten Themen referenziert. Weiterhin beinhaltet dieses Dokument keine umfassende Dokumentation der Kairos-FHIR-DSL selbst.\u00A0Voraussetzung f\u00FCr die NutzungEs wird eine konfigurierte und parametrierte CentraXX-Instanz vorausgesetzt.\u00A0Folgende Programm-Versionen wurden zur Erarbeitung der Dokumentation verwendet:ProgrammVersionCentraXX3.17.2Kairos-FHIR-DSL-Bibliothek1.7.0HL7 FHIR4.0.1IntelliJ2020.3.2Blaze0.10.3Blazectl0.2.0ZielgruppeDieses Dokument richtet sich in erster Linie an CentraXX Nutzer mit IT-Verst\u00E4ndnis, welche:die Schnittstelle verwaltenden FHIR-Export f\u00FCr Projekte konfigurierenTransformations-Skripte erarbeiten oder bearbeiten.Grundlegende Erfahrungen in Java und/oder Groovy werden ebenso vorausgesetzt wie ein Basisverst\u00E4ndnis \u00FCber den HL7-FHIR-Standard, da dieser die Grundlage f\u00FCr die hier dokumentierte Schnittstelle ist.                \n            \n                \u00DCberblick \u00FCber die SchnittstelleDer CentraXX-FHIR-Custom-Export stellt prim\u00E4r einen projektspezifisch konfigurierten FHIR Export dar. Im Rahmen der Modulation des Exportverhaltens \u00FCber ein Groovy Script werden lokal definierte CentraXX Entit\u00E4ten auf die verschiedenen\u00A0Felder einer FHIR Nachricht gemappt. Neben der vollen Kontrolle \u00FCber die zu exportierenden Inhalte erlaubt die Schnittstelle ebenfalls eine Filterung der relevanten Patienten/Probanden. Die entstehenden FHIR Bundles k\u00F6nnen dann entweder im Filesystem persistiert werden oder an eine Ziel URL eines RESTful Service \u00FCbertragen werden.Derzeit werden zwei Export-Mechanismen unterst\u00FCtzt:Scheduled Export:Hierbei wird durch eine zeitliche Planung der Export f\u00FCr alle\u00A0gefilterten Patienten gestartet.\u00A0 Der Prozess f\u00FCr den Scheduled Export wird im folgenden UML-Diagramm dargestellt:Inkrementeller Export:Der andere Exportmechanismus wird durch eine Datenver\u00E4nderung und nicht durch einen zeitlichen Trigger gestartet. Konkret bedeutet dies, dass hier nur die Patienten exportiert werden, die tats\u00E4chlich ge\u00E4ndert wurden. Sobald Daten eines Patienten in CentraXX ge\u00E4ndert werden oder ein neuer Patient angelegt wird, wird der Export f\u00FCr diesen Patienten gestartet. Der Patient muss immer noch dem projektspezifischen Patientenfilter gen\u00FCgen. Der Export wird f\u00FCr alle assoziierten Entit\u00E4ten\u00A0(Patient, Diagnosen, Verl\u00E4ufe, etc.) vorgenommen. Um die Integrit\u00E4t der Referenzierung nicht zu gef\u00E4hrden, werden bei einer \u00C4nderung der Patientendaten immer alle Entit\u00E4ten transformiert und exportiert. Der inkrementelle Export bietet somit eine effiziente M\u00F6glichkeit, um die Daten in einem FHIR-Store mit denen in CentraXX zu synchronisieren, ohne gleichbleibende Daten periodisch immer wieder zu \u00FCbertragen.Einrichtung in CentraXXKonfiguration der centraxx-dev.propertiesZur Nutzung des FHIR-Custom-Exports m\u00FCssen die Export-Funktionen allgemein aktiviert werden. Zus\u00E4tzlich muss das \u00FCbergeordnete Export-Mapping-Verzeichnis spezifiziert werden, in welchem die Unterordner der Projekte mit den spezifischen Konfigurations- und Mapping-Dateien liegen. Die Properties in der centraxx-dev.properties beziehen sich immer auf den Applikationsserver und etwaige Pfade m\u00FCssen auf dem Server vorhanden sein.\ninterfaces.fhir.custom.export.scheduled.enable=&lt;true|false&gt;\ninterfaces.fhir.custom.export.incremental.enable=&lt;true|false&gt;\ninterfaces.fhir.custom.mapping.dir=C:/applications/centraxx-home/fhir-custom-mappings\nEinrichtung eines Projekts am Beispiel einer Ausleitung f\u00FCr das DKTKDie FHIR-Ressourcen sind projektspezifisch definiert. Bei der Einrichtung von Export-Projekten f\u00FCr verschiedene FHIR-Projekte werden f\u00FCr dieselbe CentraXX-Entit\u00E4t demnach auch projektspezifische Transformations-Skripte ben\u00F6tigt. Weswegen die Transformationsskripte und Konfigurationsdateien f\u00FCr jedes Projekt in einem separaten Unterverzeichnis bereitgestellt werden.\u00A0 Als Beispiel hierzu soll ein Projekt zur Transformation der CentraXX-Entit\u00E4ten in FHIR-Profile des DKTK-Projekts angelegt werden. Die Profilierung der Ressourcen wurde durch das DKTK umgesetzt und wird von CXX lediglich abgebildet. Die FHIR Ressourcen sind unter https://simplifier.net/oncology\u00A0definiert und dokumentiert.\u00A0Daf\u00FCr ist ein Unterverzeichnis /dktk\u00A0unter interfaces.fhir.custom.mapping.dir anzulegen. Auch wenn die Benamung des Unterverzeichnisses frei ist, sollten hier sprechende Namen verwendet werden. In diesem Verzeichnis sind die Groovy-Transformations-Skripte f\u00FCr dieses Projekt abzulegen. Der resultierende Pfad aus dem Beispiel oben w\u00FCrde sich somit zu: &quot;C:/applications/centraxx-home/fhir-custom-mappings/dktk&quot; ergeben.Nach dem Anlegen eines neuen Projektverzeichnisses und einem Neustart von CentraXX wird automatisiert eine Projektkonfigurationsdatei (ProjectConfig.json) im Projektverzeichnis erzeugt. Wenn die Bedingungen des ersten Synchronisationslaufes erf\u00FCllt sind und es zu einem ersten Durchlauf der Exportroutinen kommt, wird CX zwei weitere Konfigurationsdateien erzeugen. Somit wurden insgesamt folgende drei Konfigurationsdateien erzeugt:ProjectConfig.jsonExportResourceMethodConfig.jsonBundleRequestMethodConfig.json.ProjectConfig.jsonDie ProjectConfig.json ist die Basis- Konfigurationsdatei f\u00FCr den FHIR-Export eines Export-Projekts. Diese Konfiguration kann nicht w\u00E4hrend der Laufzeit ge\u00E4ndert werden. CentraXX muss nach \u00C4nderungen dieser Datei neu gestartet werden. Die Konfigurationsdatei enth\u00E4lt f\u00FCr jeden Konfigurationsparameter ein Feld \u201Edescription\u201C, welches die Funktion des Parameters in englischer Sprache erkl\u00E4rt. Dieses Feld dient nur zur Information des Nutzers. In den folgenden Beispielen werden sehr lange Description-Strings - zur vereinfachten Darstellung - mit &quot;...&quot; abgek\u00FCrzt.Scheduled Export: Mit dieser Config wird der Scheduled Export f\u00FCr das Projekt aktiviert. Alle gefilterten CentraXX Patienten-Daten werden zum spezifizierten Zeitpunkt exportiert.&quot;scheduledExportEnable&quot;: {  &quot;description&quot;: &quot;If true, this project will export all filtered CXX patient data with the configured FHIR resources by the specified exportInterval.&quot;,  &quot;value&quot;: true},Inkrementeller Export: Aktiviert den inkrementellen Export. Wenn Patienten-Daten in CentraXX ge\u00E4ndert werden, wird der Export f\u00FCr diesen Patienten gestartet. Es werden nur Patienten ber\u00FCcksichtigt, die dem allgemeinen Patientenfilter gen\u00FCgen.&quot;incrementalExportEnable&quot;: {  &quot;description&quot;: &quot;If true, this project will export filtered CXX patient data with the configured FHIR resources by a detected change after a centraxx transaction.&quot;,  &quot;value&quot;: false},Patientenfilter: Dieser Filter spezifiziert, welche Patientendaten innerhalb des FHIR-Exports eingeschlossen werden. Der Filtertyp und der dazugeh\u00F6rige Filter-Wert werden hierzu spezifiziert. Die folgende Filtertypen stehen zur Auswahl:FilterBeschreibungPATIENTSTUDYPatient geh\u00F6rt zu einer bestimmten Studie im Studienregister. Die Studie wird folgenderma\u00DFen\u00A0spezifiziert: &quot;{studyCode}${studyProfileCode}&quot;, z.B. COVID19$BASIC.CONSENTTYPEPatient besitzt eine Einverst\u00E4ndniserkl\u00E4rung eines bestimmten Typs (Code).ORGUNITPatient geh\u00F6rt zu einer bestimmten CentraXX- Organisationseinheit (Code).FLEXIFLAGDEFPatient besitzt ein Universalattribut eines bestimmten Universalattribut-Typs (Code).IDTYPEPatient besitzt ID eines bestimmten ID-Typs (Code).Es folgt ein Beispiel zur Konfiguration eines Filters, welcher alle Patienten einschlie\u00DFt, welche eine ID des Types \u201ECOVID-19-PATIENTID\u201C besitzen:&quot;patientFilterType&quot;: {  &quot;description&quot;: &quot;...&quot;,  &quot;value&quot;: &quot;IDTYPE&quot;},&quot;patientFilterValue&quot;: {  &quot;description&quot;: &quot;The filter value.&quot;,  &quot;value&quot;: &quot;COVID-19-PATIENTID&quot;},Seitengr\u00F6\u00DFe: Bestimmt die Gr\u00F6\u00DFe einer CentraXX-Abfrage und des dazugeh\u00F6rigen FHIR-Bundles. Es wird empfohlen einen kleineren Wert zu w\u00E4hlen, wenn das Zielsystem ein Transaktions-System besitzt (z.B. 10 f\u00FCr CentraXX). Ist dies nicht der Fall, oder im Falle, dass ins Filesystem exportiert werden soll, so kann ein gr\u00F6\u00DFerer Wert gew\u00E4hlt werden (z.B. 500).&quot;pageSize&quot;: {  &quot;description&quot;: &quot;...&quot;,  &quot;value&quot;: 10},Exportzeitraum: Legt den Zeitraum des FHIR-Exportvorgangs fest. Die Zeitangabe erfolgt mittels eines sechsstelligen Chron-Ausdrucks. Mit der Standardkonfiguration erfolgt der Export jeden Tag um 12 Uhr. Hierbei sind Cron-Ausdr\u00FCcke von Spring zu verwenden.Als Beispiel die Standardkonfiguration:&quot;exportInterval&quot;: {  &quot;description&quot;: &quot;Sets the export cron interval. Default is once a day.&quot;,  &quot;value&quot;: &quot;0 0 12 * * *&quot;},Export ins Filesystem: Die FHIR-Daten k\u00F6nnen in das lokale Filesystem exportiert werden. Dazu muss der Export mit folgender Property aktiviert werden:&quot;exportToFileSystem&quot;: {  &quot;description&quot;: &quot;If true, the scheduler will export to the specified file system exportFolder.&quot;,  &quot;value&quot;: true},Zudem muss das Zielverzeichnis f\u00FCr den Export angegeben werden. Existiert das angegebene Verzeichnis nicht, wird es von CentraXX neu angelegt:&quot;exportFolder&quot;: {  &quot;value&quot;: &quot;C:/centraxx-home/fhir-custom-export&quot;},Export an URL: Die FHIR-Ressourcen k\u00F6nnen per HTTP an externe Zielsysteme transferiert werden. Diese Export-Funktion wird mit folgender Property aktiviert:&quot;uploadToUrl&quot;: {  &quot;description&quot;: &quot;If true, the scheduler will export to the specified  uploadUrl REST endpoint.&quot;,  &quot;value&quot;: false},Des Weiteren muss die URL des Zielsystems angegeben werden. Diese ist der Endpunkt einer Bundle-Ressource in einem FHIR-Store, wie Blaze oder CentraXX:&quot;uploadUrl&quot;: {  &quot;value&quot;: &quot;http://localhost:9090/fhir&quot;},Zur HTTP-Authentifizierung am Ziel-Server wird BasicAuthentication verwendet. Nutzername und Passwort werden folgenderma\u00DFen konfiguriert:&quot;uploadUser&quot;: {  &quot;description&quot;: &quot;BasicAuth User name in the target system.&quot;,  &quot;value&quot;: &quot;admin&quot;},&quot;uploadPassword&quot;: {  &quot;description&quot;: &quot;BasicAuth Password in the target system.&quot;,  &quot;value&quot;: &quot;admin&quot;},Verlangt das System keine Authentifizierung, werden die angegeben Daten f\u00FCr Nutzername und Passwort ignoriert.\u00A0 Weiterf\u00FChrend kann im Falle von &quot;uploadToUrl = true&quot; die Nutzung einer Validierung der HTTPS Zieladresse konfiguriert werden. Mit folgender Konfiguration wird spezifiziert, ob allen Zertifikaten vertraut werden kann:&quot;sslTrustAllEnable&quot;: {  &quot;description&quot;: &quot;If true, all ssl/tls certificates are trusted, otherwise the the default java store is used for SSL/TLS verification.&quot;,  &quot;value&quot;: false},Ist die Option auf &quot;false&quot; gesetzt, wird der Standard-Truststore (Java TrustStore) verwendet. Im Falle, dass auch beispielsweise system-spezifischen Zertifikaten vertraut werden kann, so k\u00F6nnen diese in einem benutzerdefinierten Truststore abgelegt werden. Als Truststore ist eine Java KeyStore-Datei (.jks) zu verwenden. Zudem sind der Pfad der Truststore-Datei im Dateisystem und das Passwort zu konfigurieren:&quot;trustStoreEnable&quot;: {  &quot;description&quot;: &quot;...&quot;,  &quot;value&quot;: false},&quot;trustStore&quot;: {  &quot;value&quot;: &quot;C:/centraxx-home/fhir-custom-truststore.jks&quot;},&quot;trustStorePassword&quot;: {  &quot;value&quot;: &quot;changeit&quot;},F\u00FCr den FHIR-Export k\u00F6nnen au\u00DFerdem das Login f\u00FCr die Anfragen und Antworten der HTTP-Requests konfiguriert werden. Das kann hilfreich zur Initialisierung und zum Testen sein. Wird bspw. ein neuer Export konfiguriert, welcher per HTTP an einen FHIR-Store ausgeweitet wird, so k\u00F6nnen die gesendeten FHIR-Ressourcen und die HTTP-Antworten des Zielservers eingesehen werden. Die Messages werden standardm\u00E4\u00DFig innerhalb des Serverlogs geloggt.\u00A0Mit folgender Option kann die HTTP-Message-Body, sprich das gesendete FHIR-Bundle, geloggt werden. \u00A0Die Konfiguration &quot;prettyPrintEnable&quot; bietet hierbei die Option diese Nachrichten f\u00FCr den Nutzer leserlich strukturiert zu loggen.\u00A0Hierbei gilt es zu beachten, dass die Aktivierung dieser Optionen bei einer hohen Anzahl von auszuleitenden Entit\u00E4ten, den Serverlog schnell f\u00FCllen werden.&quot;prettyPrintEnable&quot;: {  &quot;description&quot;: &quot;Print style the HTTP message body.&quot;,  &quot;value&quot;: false},&quot;fhirMessageLoggingEnable&quot;: {  &quot;description&quot;: &quot;If true, HTTP message requests are logged in CentraXX separately.&quot;,  &quot;value&quot;: false},Die HTTP-Antwort des Zielservers kann ebenfalls geloggt werden. Dazu muss folgende Option aktiviert sein:&quot;fhirResponseLoggingEnable&quot;: {  &quot;description&quot;: &quot;If true, HTTP message responses are logged in CentraXX separately.&quot;,  &quot;value&quot;: false},FHIR- Ressourcen werden Bundle-weise exportiert und in das Zielsystem eingeschleust. Ein solches Bundle kann bspw. Daten von f\u00FCnf Exemplaren der FHIR-Ressource 'Patient' enthalten. Bei der Verarbeitung des HTTP-Request k\u00F6nnten z.B. vier der Patienten aus der Bundle-Ressource erfolgreich importiert werden, jedoch der Import f\u00FCr einen fehlschlagen. In diesem Fall wird jedoch trotzdem eine positive HTTP-Antwort (200 OK) erzeugt. Um den Import jeder einzelnen im Bundle enthaltenen FHIR-Ressource zu validieren, muss somit die Antwort geparst und jeder Eintrag gegen die zugeh\u00F6rige FHIR-Ressource validiert werden. Diese Validierung wird mit folgender Konfiguration aktiviert:&quot;fhirResponseValidationEnable&quot;: {&quot;description&quot;: &quot;...&quot;,&quot;value&quot;: false}\u00C4nderungen an der ProjectConfig.json werden ausschliesslich beim CentraXX Neustart eingelesen. Somit werden auch \u00C4nderungen am Scheduling oder an den Filtern nur dann wirksam, wenn CentraXX neu gestartet wird.ExportResourceMappingConfig.jsonDiese Konfiguration verkn\u00FCpft eine CentraXX-Entit\u00E4t mit einer FHIR-Ressource \u00FCber ein Groovy-Transformations-Skript (groovy-Mapping). Die gleiche CentraXX-Entit\u00E4t kann so konfiguriert werden, dass sie \u00FCber verschiedene Transformations-Skripte auf die gleiche FHIR-Ressource abgebildet werden. Diese Konfiguration kann w\u00E4hrend der Laufzeit ge\u00E4ndert werden und ben\u00F6tigt keinen Neustart von CentraXX. Die Reihenfolge der Mappings ist wichtig, wenn das Zielsystem die referentielle Integrit\u00E4t pr\u00FCft (z.B. Blaze Store).\u00A0Folgend ein Besipiel f\u00FCr einen Eintrag in ExportResourceMappingConfig.json:{  &quot;selectFromCxxEntity&quot;: &quot;ORGANIZATION_UNIT&quot;,  &quot;transformByTemplate&quot;: &quot;organisation&quot;,  &quot;exportToFhirResource&quot;: &quot;Organization&quot;},Hier werden demnach Daten der CentraXX-Entit\u00E4t &quot;ORGANIZATION_UNIT&quot; mittels der Transformationsvorlage &quot;organisation&quot; auf die FHIR-Ressource &quot;Organization&quot; abgebildet. Das korrespondierende Transformations-Skript ist dann das Groovy-Skript das nach dem oben eingef\u00FChrten Beispiel unter &quot;C:\\applications\\centraxx-home\\fhir-custom-mappings\\dktk\\organisation.groovy&quot; liegt.\u00A0Hinweis: Die Eintr\u00E4ge in der Standard-Version (bei Projekt-Erstellung von CentraXX erzeugt), spezifiziert zugleich auch alle CentraXX-Entit\u00E4ten f\u00FCr die derzeit Ausleitungen m\u00F6glich sind!ResourceBundleExportConfig.jsonF\u00FCr den Export der FHIR-Ressourcen an eine Ziel-URL, k\u00F6nnen verschiedene HTTP-Methoden f\u00FCr unterschiedliche FHIR-Ressourcen-Typen verwendet werden. Welche HTTP-Methoden f\u00FCr welchen Ressourcen-Typ zu verwenden ist, h\u00E4ngt vom Zielsystem ab. In der ResourceBundleExportConfig.json Konfigurationsdatei wird den einzelnen FHIR-Ressourcen-Typen eine HTTP-Methode zugeordnet. Diese Konfiguration kann w\u00E4hrend der Laufzeit ge\u00E4ndert werden.Die Konfiguration k\u00F6nnte wie folgt aussehen:{  &quot;description&quot;: &quot;...&quot;,  &quot;resourceTypeToHttpMethod&quot;: {    &quot;Patient&quot;: &quot;PUT&quot;,    &quot;Specimen&quot;: &quot;PUT&quot;,    &quot;Condition&quot;: &quot;PUT&quot;,    &quot;Encounter&quot;: &quot;PUT&quot;,    &quot;Observation&quot;: &quot;PUT&quot;,    &quot;Procedure&quot;: &quot;PUT&quot;,    &quot;Organization&quot;: &quot;PUT&quot;,    &quot;MedicationStatement&quot;: &quot;PUT&quot;,    &quot;ClinicalImpression&quot;: &quot;PUT&quot;  }}Ist ein Ressourcen-Typ nicht konfiguriert, so wird &quot;PUT&quot; als Voreinstellung verwendet. CentraXX nutzt &quot;PUT&quot; zum Anlegen, oder Updaten \u00FCber die &quot;logical id&quot; einer FHIR-Ressource. &quot;POST&quot; wird zum Anlegen, oder Updaten \u00FCber den &quot;natural identifier&quot; (nur Patient, Specimen) genutzt.Nutzung der Groovy-DSL-BibliothekEinleitung/\u00DCberblickDSL steht f\u00FCr &quot;domain specific language&quot;. Die DSL stellt eine intuitive benutzbare Sprache dar, um Probleme einer spezifischen Dom\u00E4ne l\u00F6sen zu k\u00F6nnen. Die Kairos-FHIR-DSL wurde mit dem Ziel entwickelt, m\u00F6glichst einfach Transformation-Skripte zu schreiben, mit denen CentraXX-Entit\u00E4ten auf benutzerspezifische FHIR-Profile abgebildet werden k\u00F6nnen. Somit wird ein standardisierter Datenaustausch zwischen CentraXX und anderen FHIR-basierten Systemen erm\u00F6glicht. Die Kairos-FHIR-DSL ist in der Programmiersprache Groovy realisiert. Dementsprechend sind auch die Transformation-Skripte in Groovy zu schreiben. Um mit der DSL arbeiten zu k\u00F6nnen sind grundlegende Kenntnisse von Groovy/Java vorauszusetzen.Beispiel-Skripte f\u00FCr die Transformation von CentraXX-Entit\u00E4ten zu FHIR-Profilen k\u00F6nnen in Form eines\u00A0Beispielprojekte heruntergeladen werden. Ausschnitte aus diesen Skripten werden im weiteren Verlauf der vorliegenden Dokumentation exemplarisch erl\u00E4utert. F\u00FCr folgende FHIR-Projekte werden Beispiel-Skripte zur Verf\u00FCgung gestellt:DKTKBBMRICentraXX zu CentraXXDie Kairos-FHIR-DSL-Bibliothek ist im\u00A0Beispielprojekt bereits eingebunden. Selbstverst\u00E4ndlich kann sie aber auch in eigene Groovy-Projekte eingebunden werden. Zum Erstellen und Editieren der Groovy-Skripte unter zur Hilfenahme von Codecompletion und Syntaxhighlighting werden entsprechende IDE Umgebungen ben\u00F6tigt. Der Download und die Installation aller ben\u00F6tigten Programme werden folgend beschrieben.Voraussetzungen zur Nutzung der Kairos-FHIR-DSL Bibliothek und des BeispielprojektsIDE mit Maven und Groovy Support, z.B. IDEA IntelliJ, Eclipse, etc.Um die Groovy-Transformationsskripte zu erarbeiten, wird eine Entwicklungsumgebung genutzt. Im Folgenden wird die Einrichtung mit IDEA IntelliJ beschrieben. Die derzeit kostenfreie Community-Edition ist hierf\u00FCr ausreichend. Den Installer k\u00F6nnen Sie auf der IntelliJ Webseite herunterladen (https://www.jetbrains.com/idea/)Adopt-JDK 1.8 (Zur Nutzung der FHIR-Bibliothek wird derzeit ein Java Development Kit 8 ben\u00F6tigt. W\u00E4hlen Sie bei der Installation &quot;JAVA_HOME Variable konfigurieren&quot; aus.)Maven\u00A0IntelliJ selbst\u00A0kommt mit einem vorinstallierten Maven. Damit Maven \u00FCber die Kommandozeile genutzt werden kann, was zur Installation der Kairos-FHIR-DSL Bibliothek f\u00FCr eigene Groovy-Projekte sehr hilfreich ist, muss es zum &quot;Path&quot; hinzugef\u00FCgt werden. F\u00FCgen Sie dazu der Systemvariable &quot;Path&quot; den Pfad &quot;[IntelliJ]\\plugins\\maven\\lib\\maven3\\bin&quot; hinzu.\u00A0Es kann auch ein eigenes Maven installiert werden. Maven kann unter dem folgenden Link heruntergeladen werden: https://maven.apache.org/download.cgi\u00A0.\u00A0Maven wird nach folgender Anleitung installiert: https://maven.apache.org/install.html.\u00A0Konfiguration eines benutzerspezifischen Maven:Im Falle, dass nicht das Maven verwendet werden soll, welches mit IntelliJ vorinstalliert wird, kann dieses in IntelliJ einfach ge\u00E4ndert werden. Dies l\u00E4sst sich unter File \u2192 Settings \u2192 Build, Execution, Deployment \u2192 Build Tools \u2192 Maven, konfigurieren. An dieser Stelle muss der &quot;maven home path&quot; auf &quot;[custom-maven]/bin&quot; gesetzt werden.Konfiguration des JDK 8 als Projekt-JDK:Um das ben\u00F6tigte JDK 8 f\u00FCr das Projekt zu nutzen, muss dieses in intelliJ konfiguriert werden. Gehen Sie dazu unter File \u2192 Project Structure... \u2192 Project und setzen Sie hier unter &quot;Project SDK&quot; den Pfad auf das Adopt-JDK 8. Wenn der Standard-Pfad bei der Installation nicht ge\u00E4ndert wurde, dann sollte &quot;C:\\Program Files\\AdoptOpenJDK\\jdk-8.0.275.1-hotspot&quot; gew\u00E4hlt werden.Installation des FHIR-BeispielprojektsEs existiert ein Beispiel-Projekt, welches Groovy-Mappings f\u00FCr verschiedene Projekte bereith\u00E4lt. Diese umfassen momentan Mappings f\u00FCr die Projekte DKTK, BBMRI (GBA/GBN) und CXX (CentraXX zu CentraXX-Synchronisation per FHIR). Dieses Projekt wird auf Github verwaltet. Der aktuelle Release kann ebenfalls von Github heruntergeladen werden. Gehen Sie dazu auf folgende Seite. Hier sehen Sie eine Liste mit allen Releases. Downloaden Sie den Source Code des neusten Releases und entpacken Sie die heruntergeladene Zip-Datei in das Verzeichnis, in dem Ihr Projekt liegen soll.\u00A0 Nun kann das Projekt in IntelliJ ge\u00F6ffnet werden. Gehen Sie dazu unter File\u00A0\u2192 New\u00A0\u2192 Project from Existing Sources... und geben Sie den Pfad [kairos-fhir-mapping-example]/pom.xml an und erstellen Sie das Projekt. Damit Maven die Kairos-FHIR-DSL-Bibliothek, die auch auf Github bereitsteht, ins Projekt einbeziehen kann, muss die &quot;settings.xml&quot; Datei konfiguriert werden. Dazu gehen Sie unter File\u00A0\u2192 Settings\u00A0\u2192 Build, Execution, Deployment\u00A0 \u2192 Build Tools und klicken\u00A0&quot;Maven&quot;. Im ge\u00F6ffneten Fenster setzen Sie bei &quot;User settings file&quot; im K\u00E4stchen &quot;Override&quot; den Haken und w\u00E4hlen dort folgenden Pfad aus: [Projekt-Root]/settings.xml.\u00A0Falls Sie ein eigenes Maven im Projekt verwenden wollen, konfigurieren Sie dieses im Feld &quot;Maven home path&quot;. Klicken Sie &quot;Apply&quot; und dann &quot;Ok&quot;. Gehen Sie ins in Maven-Fenster (rechts) unter [Projektname] \u2192 Lifecycle \u2192 Install oder f\u00FChren Sie $ mvn install -s &lt;path to settings.xml&gt; im Terminal aus. Nachdem dieser Vorgang abgeschlossen ist, klicken Sie im Maven-Fenster oben links den &quot;Reload All Maven Projects&quot;-Button, damit maven alle notwendigen Plugins l\u00E4dt. Gegebenenfalls muss noch das Projekt-JDK, wie oben beschrieben, konfiguriert werden.Installation der FHIR-DSL-BibliothekDie Kairos-FHIR-DSL-Bibliothek wird mittels Maven \u00FCber Github installiert. Erstellen Sie dazu ein neues Projekt in IntelliJ. Im Dialog muss links Groovy ausgew\u00E4hlt werden. Im n\u00E4chsten Fenster wird das Projektverzeichnis konfiguriert. Nachdem das Projekt initialisiert wurde, muss Maven als Framework hinzugef\u00FCgt werden. Dazu rechtsklicken Sie im Projekt-Fenster das Projektverzeichnis-Root-Element und w\u00E4hlen &quot;Add Framework Support...&quot;.\u00A0 Im neuen Fenster setzen Sie den Haken bei &quot;Maven&quot; und best\u00E4tigen die Eingabe mit &quot;OK&quot;. Es wird eine &quot;pom.xml&quot; Datei erstellt. Innerhalb dieser m\u00FCssen folgende Eintr\u00E4ge hinzugef\u00FCgt werden, sodass die Kairos-FHIR-DSL-Bibliothek in das Projekt eingebunden werden kann:&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;de.kairos&lt;/groupId&gt;        &lt;artifactId&gt;kairos-fhir-dsl&lt;/artifactId&gt;        &lt;version&gt;1.6.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;repositories&gt;    &lt;repository&gt;        &lt;id&gt;github-kairos-fhir&lt;/id&gt;        &lt;name&gt;GitHub kairos-fhir Apache Maven Packages&lt;/name&gt;        &lt;url&gt;https://maven.pkg.github.com/kairos-fhir/kairos-fhir-dsl-mapping-example&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;Der obere Eintrag spezifiziert die Dependency und der untere das Repository, wo diese zu finden ist. Github erfordert bislang f\u00FCr den automatischen Dependeny-Download per Maven immer eine Authentifizierung \u00FCber einen Access-Token. Um die Arbeit zu erleichtern wurde ein allgemeiner Access-Token im Github-Projekt als &quot;settings.xml&quot; mit ver\u00F6ffentlicht. Legen Sie sich in Ihrem IntelliJ-Projekt ebenfalls eine eigene Settings-XML-Datei an und f\u00FCgen Sie den Datei-Inhalt aus Github ein. Gehen Sie nun unter File\u00A0\u2192 Settings\u00A0\u2192 Build, Execution, Deployment\u00A0 \u2192 Build Tools und klicken\u00A0&quot;Maven&quot;. Im ge\u00F6ffneten Fenster setzen Sie bei &quot;User settings file&quot; im K\u00E4stchen &quot;Override&quot; den Haken und w\u00E4hlen den Pfad zu der eben erstellten XML-Datei aus. Falls Sie ein eigenes Maven im Projekt verwenden wollen, konfigurieren Sie dieses im Feld &quot;Maven home path&quot;. Klicken Sie &quot;Apply&quot; und dann &quot;Ok&quot;. Nun gehen Sie rechts im Maven-Fenster und w\u00E4hlen [Projektname] \u2192 Lifecycle \u2192 Install oder f\u00FChren sie $ mvn install\u00A0 -s &lt;path to custom settings xml&gt; im IntelliJ-Terminal aus.Verwendung der DSL-Bibliothek zur Erstellung von Transformations-SkriptenAllgemeinesGroovy bietet mit Closures ein Sprachelement, dass f\u00FCr die Entwicklung einer DSL ma\u00DFgeblich ist. Closures sind Code-Bl\u00F6cke, die in Groovy als Klasse behandelt werden und damit auch als Argumente an Methoden \u00FCbergeben werden k\u00F6nnen. In Closures selbst k\u00F6nnen wiederum Methoden aufgerufen werden. Dies wird genutzt, um eine intuitive Syntax zur Abbildung von FHIR-Profilen zu bieten. Um bei Interesse Groovy-Closures und -Delegations besser verstehen zu k\u00F6nnen, wird die Groovy-Dokumentation des Apache Projekts empfohlen.\u00DCber die Delegations-Strategie kann bestimmt werden, welche Methoden in einem Closure aufgerufen werden k\u00F6nnen. Beim Aufruf einer solchen Methode, wird zur Laufzeit versucht die entsprechenden Implementationen der im Closure aufgerufenen Methode \u00FCber den Delegations-Mechanismus zu finden. Um als Nutzer die DSL verwenden zu k\u00F6nnen, wird die Information ben\u00F6tigt, welche Methoden in welchen Closures aufgerufen werden k\u00F6nnen. Dies wird bei der Entwicklung der DSL in Groovy, mittels Annotationen realisiert. Dadurch wird eine Auto-Code-Vervollst\u00E4ndigung in der Entwicklungsumgebung erm\u00F6glicht.Zusammenbau der FHIR Nachricht mit Groovy ClosuresIm Folgenden soll das Prinzip des Closures und weiterer Groovy-Spezifit\u00E4ten aufgef\u00FChrt werden, die zur Erstellung von Transformations-Skripten genutzt werden k\u00F6nnen. Dazu wird das Groovy Skript &quot;patient.groovy&quot; betrachtet, dass im Beispielprojekt unter \\src\\main\\java\\projects\\dktk_with_jpa_navigation\\patient.groovy vorzufinden ist. Dieses Skript bildet die CentraXX-Entit\u00E4t PatientMasterDataAnonymous auf das DKTK FHIR-Profil &quot;patient&quot; ab.(Screengrab von\u00A0https://simplifier.net/oncology/patientenpseudonym\u00A0)Die Kairos-FHIR-DSL repr\u00E4sentiert die Struktur des FHIR-Profils. Die in der Bibliothek bereitgestellten Methoden tragen die Namen der zugeh\u00F6rigen Elemente eines FHIR-Profils. Es wird daher zun\u00E4chst die \u00E4u\u00DFere Methode &quot;patient&quot; aufgerufen. Diese akzeptiert ein Closure als Argument. Hier werden zuerst zwei generelle Elemente einer FHIR-Ressource festgelegt. F\u00FCr das FHIR-Profil werden die Elemente &quot;id&quot; und &quot;meta&quot; gesetzt und deshalb k\u00F6nnen in diesem Closure die Methoden &quot;id&quot; und &quot;meta&quot; aufgerufen werden. Die Basis-Definition einer FHIR-Resource sieht folgenderma\u00DFen aus:(Screengrab von\u00A0http://www.hl7.org/fhir/resource.html\u00A0)Das Element &quot;id&quot; ist ein &quot;Simple Type&quot;, es besitzt demnach einen Wert. Das Element &quot;meta&quot; ist wiederum ein &quot;Complex Type&quot; und kann folglich verschiedene Unterelemente besitzen. Im Detail sieht die Definition des komplexen Elements &quot;meta&quot; wie folgt aus:(Screengrab von\u00A0http://www.hl7.org/fhir/resource.html#Meta\u00A0)Damit werden auch die Methodenaufrufe im Groovy-Skript ersichtlicher. Prinzipiell repr\u00E4sentieren diese, die Struktur des FHIR-Profils.patient {  id = &quot;Patient/&quot; + context.source[patientMasterDataAnonymous().patientContainer().id()]  meta {    profile &quot;http://dktk.dkfz.de/fhir/StructureDefinition/onco-core-Patient-Pseudonym&quot;  }  ...}Im Closure, welches die Methode &quot;patient&quot; als Argument akzeptiert, d\u00FCrfen die Methoden &quot;id&quot;, &quot;meta&quot;, &quot;implicitRules&quot; und &quot;language&quot; aufgerufen werden, da diese entsprechend in der Struktur-Definition des FHIR-Profils f\u00FCr eine Resource definiert sind. In IntelliJ kann das \u00FCberpr\u00FCft werden, indem ein gew\u00FCnschter Element-Namen eingegeben wird. Dieser wird darauffolgend direkt von der Auto-Code-Vervollst\u00E4ndigung angezeigt.Im Beispiel wird au\u00DFerdem dem Feld &quot;id&quot; ein String zugewiesen. In Groovy k\u00F6nnen Klassen sogenannte Properties besitzen, welchen mit dieser Syntax direkt ein Wert zugewiesen werden kann. In Java entspricht eine Property einem &quot;private&quot; Feld einer Klasse. Diese Zuweisung ist somit analog zum Aufruf der zugeh\u00F6rigen Setter-Methode. Groovy bietet f\u00FCr Properties von Klassen direkt Setter- und Getter-Methoden an, ohne das diese implementiert werden m\u00FCssen. Die oben gezeigte Zuweisung kann alternativ wie folgt geschrieben werden:patient {  setId &quot;Patient/&quot; + context.source[patientMasterDataAnonymous().patientContainer().id()]  ...} Der Ausdruck &quot;context.source&quot; wird weiter unten ausf\u00FChrlicher erl\u00E4utert.Das Element &quot;meta&quot;\u00A0kann weitere Unterelemente besitzen und daher nimmt die zugeh\u00F6rige Methode wiederum ein Closure als Argument. In diesem Closure k\u00F6nnen nun laut FHIR-Profil-Definition die Methoden &quot;versionId&quot;, &quot;lastUpdated&quot;, &quot;source&quot;, &quot;profile&quot;, &quot;security&quot; und &quot;tag&quot; aufgerufen werden. Die Auto-Vervollst\u00E4ndigung sollte in IntelliJ folgenderma\u00DFen aussehen:Prinzipiell werden die Methoden entsprechend des zu kreierenden FHIR-Profils ineinander geschachtelt. Methoden, die einem FHIR-Element von komplexem Typ entsprechen akzeptieren ein Closure als Argument, in welchem genau die korrespondierenden Methoden f\u00FCr die Unterelemente aufgerufen werden k\u00F6nnen. In der Abbildung oben rechts sehen Sie das Beispiel der Code-Vervollst\u00E4ndigung f\u00FCr die Methode &quot;security&quot;. Hat ein Element im FHIR-Profil nur einen Wert, so kann dieser direkt zugewiesen werden. Der entsprechende Aufruf ist in IntelliJ mit einem violett hinterlegten \u201Ep\u201C gekennzeichnet (z.B.: &quot;versionId&quot; in linker Abbildung). Im Falle, dass unter &quot;meta&quot; das Feld &quot;versionId&quot; mit &quot;EXAMPLE-ID&quot; festgelegt werden soll, so sieht der Code wie folgt aus:patient {  ...  meta {    profile &quot;http://dktk.dkfz.de/fhir/StructureDefinition/onco-core-Patient-Pseudonym&quot;    versionId = &quot;EXAMPLE-ID&quot;  }  ... }Soll nun das komplexe Element &quot;security&quot; gesetzt werden, so muss ein Closure aufgerufen werden. &quot;meta.security&quot; ist vom Typ Coding. Die Struktur f\u00FCr ein &quot;Coding&quot; ist hier definiert. Des Weiteren ist f\u00FCr &quot;Security&quot; ein\u00A0ValueSet definiert. Mit dieser Information kann nun die DSL genutzt werden, um das entsprechende Closure bspw. wie folgt aufzurufen:patient {  ...  meta {    profile &quot;http://dktk.dkfz.de/fhir/StructureDefinition/onco-core-Patient-Pseudonym&quot;    versionId = &quot;EXAMPLE-ID&quot;    security {      system = &quot;http://terminology.hl7.org/CodeSystem/v3-Confidentiality&quot;      code = &quot;U&quot;    }  }  ...}Dies ist nur ein Beispiel, um den Methodenaufruf mit einem Closure zu demonstrieren. Im eigentlichen Anwendungsfall k\u00F6nnen selbstverst\u00E4ndlich die zugewiesenen Werte von den Daten der CentraXX-Entit\u00E4t abh\u00E4ngen.CXX JPA Meta Model und die Verwendung von context.source mit der JPA-NavigationJPA Meta ModelDas Ziel der Mappings ist, die Daten einer CentraXX-Entit\u00E4t auf ein FHIR-Profil abzubilden. Daf\u00FCr m\u00FCssen die Daten vom Datenmodell der zu transformierenden CentraXX-Entit\u00E4t abgerufen werden k\u00F6nnen. Dazu wird der Ausdruck &quot;context.source&quot; verwendet. Das Objekt &quot;context.source&quot; ist eine Repr\u00E4sentation der CentraXX-Entit\u00E4t in Form geschachtelter Hash-Maps. Eine Hash-Map ordnet einem Schl\u00FCssel (Key) einen Wert (Value) zu. Als Schl\u00FCssel wird jeweils der Name der Java JPA Property verwendet. Value ist entweder ein Simple Type (beispielsweise ein String), oder wiederum eine Hash-Map. Diese Struktur erm\u00F6glicht es in Groovy, Elemente in Form von geketteten Aufrufen, wie context.source[propertyX.propertryY.propertyZ] abzurufen. Im ersten Beispiel oben ist dieser Ausdruck bereits vorgekommen.Navigation mittels verketteter MethodenaufrufeEine effiziente Nutzung der Datenabfrage \u00FCber context.source ist nur m\u00F6glich, wenn die Struktur des JPA-Meta-Models bekannt ist und man somit wei\u00DF, welche Keys die CentraXX-Entit\u00E4t \u00FCberhaupt besitzt. Dies wird in der Kairos-FHIR-DSL durch die Implementation hierarchische Klassen realisiert, welche die Struktur des JPA-Meta-Models repr\u00E4sentieren. Diese Repr\u00E4sentation basiert auf einem String-Builder, welcher Methoden zu den m\u00F6glichen JPA-Keys einer CentraXX-Entit\u00E4t anbietet. Somit wird eine Navigationsm\u00F6glichkeit bereitgestellt, um passende Keys f\u00FCr die jeweiligen Entit\u00E4ten zu generieren und daf\u00FCr Code-Vervollst\u00E4ndigung zu nutzen. Die oberste Klasse &quot;RootEntities&quot; bietet hierzu statische Methoden zu allen verf\u00FCgbaren CentraXX-Entit\u00E4ten mit korrespondierendem Namen an. Bei der folgenden Zuweisung der Property &quot;id&quot;, wird das Element &quot;id&quot; von context.source abgerufen.id = &quot;Condition/&quot; + context.source[&quot;id&quot;]Mit Hilfe der JPA-Navigation kann dies folgenderma\u00DFen geschrieben werden:id = &quot;Condition/&quot; + context.source[RootEntities.diagnosis().id()]Mit &quot;RootEntities.diagnosis()&quot; werden die Navigationsm\u00F6glichkeiten f\u00FCr die CentraXX-Entit\u00E4t &quot;Diagnosis&quot; ausgew\u00E4hlt. Dieser Ausdruck kann weiter vereinfacht werden. In einem Groovy-Skript wird nur eine CentraXX-Entit\u00E4t transformiert und somit werden immer nur Werte von derselben Entit\u00E4t abgerufen. &quot;RootEntities.diagnosis&quot; kann somit als statischer Import hinzugef\u00FCgt werden. Dazu rechtsklicken Sie in IntelliJ die Methode &quot;diagnosis()&quot; und gehen auf Show Context Actions \u2192 Add static import. Somit kann der Ausdruck einfacher genutzt werden:id = &quot;Condition/&quot; + context.source[diagnosis().id()]Oder hier ein weiteres Beispiel:subject {  reference = &quot;Patient/&quot; + context.source[diagnosis().patientContainer().id()]}Es ist wichtig, sich klar zu machen, dass das &quot;RootEntities&quot; lediglich ein String-Builder ist, der je nach Aufruf seiner Methoden einen geketteten JPA-Schl\u00FCssel als String zur\u00FCckgibt. Die Daten der CentraXX-Entit\u00E4t sind in contex.source enthalten. Mit den Strings, k\u00F6nnen die entsprechenden Elemente von context.source abgerufen werden. F\u00FChrt man folgendes Skript aus,import de.kairos.fhir.centraxx.metamodel.RootEntitiesprintln RootEntities.abstractSample().active().path()println RootEntities.patientMasterDataAnonymous().patientContainer().idContainer().creator().username().path()dann erh\u00E4lt man folgenden Output:&quot;active&quot;&quot;patientcontainer.idContainer.creator.username&quot;Die resultierenden Strings enthalten nicht den Namen der Centraxx-Entit\u00E4t selbst (AbstractSample, PatientMasterDataAnonymous), da diese Information durch das Ressourcen-Mapping in contex.source enthalten ist. Die Methode &quot;path()&quot; ist die Builder-Methode, die den String zur\u00FCckgibt. Diese Methode muss nicht explizit aufgerufen werden, wenn der Ausdruck innerhalb des Subscript-Operators von context.source aufgerufen wird, da context.source den Aufruf der &quot;path&quot;-Methode selbst implementiert.Verwendung von Konstanten in Listen-ClosuresIn manchen F\u00E4llen werden in Transformations-Skripten Listen von Elementen verarbeitet. Groovy-Listen bieten daf\u00FCr verschiedene Funktionen an, welche ein Closure als Argument akzeptieren. Im folgenden Beispiel aus dem Skript /dktk_with_jpa_navigation/specimen.groovy soll f\u00FCr jeden Eintrag im IdContainer ein FHIR-Element &quot;identifier&quot; festgelegt werden. Hierzu wird die Methode &quot;each&quot; verwendet:context.source[abstractSample().idContainer()]?.each { final idc -&gt;  identifier {    value = idc[PSN]    type {      coding {        system = &quot;urn:centraxx&quot;        code = idc[ID_CONTAINER_TYPE]?.getAt(CODE)      }    }    system = &quot;urn:centraxx&quot;  }}Zun\u00E4chst wird der IdContainer abgefragt und mittels des &quot;?&quot;-Operators gepr\u00FCft, ob dieser \u00FCberhaupt vorhanden ist. Beim Iterieren \u00FCber die Elemente des IdContainers wird einer lokalen variable &quot;idc&quot; jeweils das Element zugewiesen. Im Closure der &quot;each&quot;-Methode werden nun wiederum Felder dieses Elements abgerufen. Jetzt befindet man sich allerdings nicht mehr in contex.source, sondern greift jetzt auf die Felder des neuen Objekts &quot;idc&quot; zu. Das Objekt &quot;idc&quot; ist wiederum eine geschachtelte Map. Um zu wissen, welche Keys diese Map besitzen kann, muss man wissen, welcher Entit\u00E4t des CentraXX JPA-Model dieses Objekt entspricht. Dies findet man schnell heraus, wenn man sich anschaut, welchen Typ die Methode &quot;idContainer()&quot; zur\u00FCckgibt. Dazu reicht es in IntelliJ den Cursor auf der entsprechenden Methode zu platzieren. Die Methode &quot;idContainer()&quot; gibt einen &quot;SampleIdContainer&quot; zur\u00FCck. Jede Klasse der JPA-Repr\u00E4sentation bietet die zugeh\u00F6rigen Keys als Konstanten an. Damit k\u00F6nnen nun die Felder von &quot;idc&quot; mit den passenden Keys abgerufen werden. Das Beispiel oben ist bereits mit statischen Importen vereinfacht. Die Aufrufe, die im Closure der &quot;identifier&quot;-Methode get\u00E4tigt werden, sehen unvereinfacht wie folgt aus:identifier {  value = idc[SampleIdContainer.PSN]  type {    coding {      system = &quot;urn:centraxx&quot;      code = idc[SampleIdContainer.ID_CONTAINER_TYPE]?.getAt(IdContainerType.CODE)    }  }  system = &quot;urn:centraxx&quot;}Auf diese Weise funktioniert auch die zweite Zuweisung. Dort muss man wissen, dass &quot;idc[ID_CONTAINER_TYPE]&quot; ein Objekt vom Typ &quot;IdContainerType&quot; zur\u00FCckgibt. Hier st\u00F6\u00DFt die Code-Vervollst\u00E4ndigung allerdings an ihre Grenzen. Jedoch ist aus der Benamung der Klassen leicht zu erkennen, welcher Typ zur\u00FCckgegeben wird. Alternativ kann man beim Skripten auch testweise den linearen Ausdruck schreiben und mittels der Code-Vervollst\u00E4ndigung in IntelliJ den Return-Type herausfinden.\u00A0\u00A0 Definition eigener Methoden, um CentraXX-Entit\u00E4ten optimal abzubildenBeispiel 1: Abbildung des CentraXX Gender auf das Gender des DKTK-FHIR-ProfilsEs treten F\u00E4lle auf, in denen die Daten einer CentraXX-Identit\u00E4t anders strukturiert sind als im zugeh\u00F6rigen FHIR-Profil. Dies h\u00E4ngt bspw. davon ab, welcher Satz an Werten zur Beschreibung eines bestimmten Patienten-Stammdatenpunkts in einer CentraXX-Instanz definiert ist. Betrachten wir z.B. das Element &quot;Gender&quot; im FHIR-Profil im Vergleich zur Definition in CentraXX. F\u00FCr das FHIR-Profil ist folgender ValueSet definiert. Nachfolgend wird ein Beispiel f\u00FCr die Dokumentation des Geschlechts eines Patienten in CentraXX und in der FHIR-Ressource &quot;Patient&quot; des DKTK-Projekts aufgef\u00FChrt:CentraXXDKTK FHIR Resource &quot;Patient&quot;m\u00E4nnlichweiblichhermaphroditischunbekanntunbestimmtsonstigesdiversmalefemaleotherunknownUm die Werte optimal zu ordnen zu k\u00F6nnen, kann eine eigene Methode definiert werden, um das CentraXX-Gender abzubilden. Folgend ein Ausschnitt aus \\dktk_with_jpa_navigation\\patient.groovy:patient {  ...    if (context.source[patientMasterDataAnonymous().genderType()]) {    gender = mapGender(context.source[patientMasterDataAnonymous().genderType()] as GenderType)  }}Mittels if-Statement wird gepr\u00FCft, ob f\u00FCr den zu transformierenden Patienten-Datensatz \u00FCberhaupt ein Gender angegeben ist. Dazu wird &quot;context.source&quot; genutzt, um dieses von der CentraXX-Entit\u00E4t abzufragen. Ist das Gender definiert wird der Property &quot;gender&quot; der Wert mit der eigenen Methode &quot;mapGender()&quot; zugewiesen. Diese Methode ist folgenderma\u00DFen definiert:static AdministrativeGender mapGender(final GenderType genderType) {  switch (genderType) {    case GenderType.MALE:      return AdministrativeGender.MALE    case GenderType.FEMALE:      return AdministrativeGender.FEMALE    case GenderType.UNKNOWN:      return AdministrativeGender.UNKNOWN    default:      return AdministrativeGender.OTHER  }}Mit einem Switch-Statement k\u00F6nnen die entsprechenden F\u00E4lle zugeordnet werden. Da die zus\u00E4tzlichen Gender, wie bspw. &quot;hermaphroditisch&quot; nicht im FHIR ValueSet definiert sind, werden diese im Beispiel auf &quot;Other&quot; abgebildet. In diesem Fall bietet die FHIR-Bibliothek ein Enum &quot;AdministrativeGender&quot; an, in welchem die konstanten Werte des ValueSets definiert sind.Beispiel 2: Setzen der &quot;identifier&quot; f\u00FCr DKTK FHIR-Profil Patient: Das Element &quot;identifier&quot; des FHIR-Profils wird folgenderma\u00DFen festgelegt. Der folgende Code ist erneut ein Ausschnitt aus dem Beispielskript \\dktk_with_jpa_navigation\\patient.groovy:patient {  ...  final def globalId = context.source[patientMasterDataAnonymous().patientContainer().idContainer()]?.find {    &quot;DKTK&quot; == it[ID_CONTAINER_TYPE]?.getAt(CODE)   }  if (globalId) {    identifier {      value = globalId[PSN]      type {        coding {          system = &quot;http://dktk.dkfz.de/fhir/onco/core/CodeSystem/PseudonymArtCS&quot;          code = &quot;Global&quot;         }      }    }  }  ...}Zuerst wird einer Variable &quot;globalId&quot; ein Wert zugewiesen. Groovy unterst\u00FCtzt sowohl statische als auch dynamische Typisierung. In diesem Fall wird &quot;globalId&quot; dynamisch typisiert. Sie nimmt also den Typ an, der Ihr zu Laufzeit zugewiesen wird. In Groovy wird dazu das Keyword &quot;def&quot; verwendet. Mittels des &quot;?&quot;-Operator wird \u00FCberpr\u00FCft, ob \u00FCberhaupt eine Property &quot;patientcontainer.idContainer&quot; vorhanden ist. Im Falle, dass diese vorhanden ist, so generiert context.source[&quot;patientContainer.idContainer&quot;] eine Liste zur\u00FCck.\u00A0 Diese Liste enth\u00E4lt wiederum geschachtelte Maps. In dieser Liste wird nach einem Element (also einer Map) gesucht, welches als Key die Property &quot;idContainerType&quot; besitzt. Da in CentraXX ein Patient prinzipiell mehrere IdContainer besitzen kann, wird das Ergebnis im .find Ausdruck weiter nach dem jeweiligen idContainertypeType mit dem &quot;code&quot;=&quot;DKTK&quot; gefiltert, um zu einem eindeutigen Ergebnis zu gelangen. Ist dies wiederum der Fall, so wird die Variable &quot;globalId&quot; mit dem Ergebnis, der Map, welche den IdContainer representiert, belegt. Wird keine passende Map gefunden bleibt &quot;globalId&quot; gleich null.Der zweite Code-Abschnitt wird nur ausgef\u00FChrt, wenn \u201EglobalId\u201C ungleich null ist, sprich eine entsprechende Map existiert. Hierbei wird die Methode &quot;identifier&quot; des FHIR-Modells f\u00FCr den Zusammenbau eines Patienten aufgerufen. Dem Element &quot;value&quot; in &quot;identifier&quot; wird nun der Value aus der Map zum Key der Property &quot;psn&quot;, der vorher definierten Variablen &quot;globalId&quot; zugewiesen. FHIR-Export in ZielsystemeF\u00FCr die folgenden Beispiele wurde ein Projekt-Verzeichnis unter &quot;[centraxx-home]\\fhir-custom-mappings\\dktk&quot; angelegt. Innerhalb dieses wurden alle Groovy-Skripte aus dem Beispielprojekt (s. oben) abgelegt.\u00A0Die Konfigurationsdatei ExportResourceMappingConfig.json wurde f\u00FCr dieses Beispiel auf dem Standard-Zustand belassen (so wie sie nach dem ersten Start von CentraXX nach Anlegen des Projekt-Ordners von CentraXX erstellt wurde).\u00A0Es wurden drei Testpatienten in CentraXX angelegt. Des Weiteren wurde die Patienten-ID mit dem Code &quot;DKTK&quot; in CentraXX definiert. Diesen drei Testpatienten wurde eine solche &quot;DKTK&quot;-ID zugewiesen. Somit kann ein passender Patienten-Filter konfiguriert werden:&quot;patientFilterType&quot;: {  &quot;description&quot;: &quot;...&quot;,  &quot;value&quot;: &quot;IDTYPE&quot;},&quot;patientFilterValue&quot;: {  &quot;description&quot;: &quot;The filter value.&quot;,  &quot;value&quot;: &quot;DKTK&quot;},Zum Testen ist es hilfreich, wenn\u00A0 Ausleitungen zeitnah stattfinden. Dazu wird f\u00FCr die folgenden Beispiele ein Exportintervall auf alle f\u00FCnf Minuten konfiguriert:&quot;exportInterval&quot;: {  &quot;description&quot;: &quot;Sets the export cron interval. Default is once a day.&quot;,  &quot;value&quot;: &quot;0 */5 * * * *&quot;},Ein Beispiel f\u00FCr ein ausgeleitetes FHIR-Bundle der FHIR-Ressource Patient finden Sie im Anhang.Ausleitung in einen Blaze StoreFHIR-Ressourcen k\u00F6nnen in einen Blaze-Store ausgeleitet werden. F\u00FCr dieses Beispiel wird das &quot;standalone JAR&quot;-Blaze verwendet. Hinweise zur Installation finden Sie unter https://alexanderkiel.gitbook.io/blaze/ und unter\u00A0https://github.com/samply/blaze. Zus\u00E4tzlich wird ein weiteres Command-Line-Tool verwendet, mit dem im nachfolgenden Beispiel die Anzahl der Ressourcen im Blaze-Store abgefragt werden k\u00F6nnen. Hinweise zur Installation und Nutzung von Blaze-CTL finden Sie unter\u00A0https://github.com/samply/blazectl.Blaze bietet eine REST-full API standardm\u00E4\u00DFig unter http:\\\\localhost:8080\\fhir an. F\u00FCr einen Export in den Blaze-Store m\u00FCssen die Konfigurationen in ProjectConfig.json (spezifische Erl\u00E4uterung im Abschnitt &quot;Einrichtung eines Projekts&quot;) angepasst werden. Der Export per HTTP muss aktiviert und die Adresse des Zielsystems festgelegt werden.&quot;uploadToUrl&quot;: {  &quot;description&quot;: &quot;If true, the scheduler will export to the specified uploadUrl REST endpoint.&quot;,  &quot;value&quot;: true},&quot;uploadUrl&quot;: {  &quot;value&quot;: &quot;http://localhost:8080/fhir&quot;},Au\u00DFerdem werden f\u00FCr diesen Test alle Zertifikate zugelassen:&quot;sslTrustAllEnable&quot;: {  &quot;description&quot;: &quot;If true, all ssl/tls certificates are trusted, otherwise the the default java store is used for SSL/TLS verification.&quot;,  &quot;value&quot;: true},F\u00FCr erste Testzwecke ist es sinnvoll das Login der HTTP-Antwort des Zielservers zu aktivieren:&quot;prettyPrintEnable&quot;: {  &quot;description&quot;: &quot;Print style the HTTP message body.&quot;,  &quot;value&quot;: true},&quot;fhirResponseValidationEnable&quot;: {  &quot;description&quot;: &quot;If true, the HTTP message responses is parsed and each response entry is validated against its FHIR response status. Even if the HTTP response status is 200 ok, the status of a single entry might be 400 (bad request). If the status is not 200 or 201, an error is logged.&quot;,  &quot;value&quot;: true}Die hier nicht aufgef\u00FChrten Konfigurationen werden bei dem Standard-Werten belassen. Der Patientenfilter und das Ausleitungsintervall sind, wie oben beschrieben, konfiguriert.Die Konfigurationsdatei BundleRequestMethodConfig.json kann auf dem Standard-Zustand belassen werden. Standardisiert werden f\u00FCr alle FHIR-Ressourcen-Typen die PUT-Methode verwendet. Da Blaze ausschlie\u00DFlich PUT akzeptiert, bedarf es hier keiner Modifizierung.CentraXX muss nun neu gestartet werden, um den neu konfigurierten Export zu aktivieren. Davor kann bereits Blaze selbst gestartet und eine erste Abfrage \u00FCber die Anzahl der Ressourcen in Blaze get\u00E4tigt werden. Dazu muss der folgende Befehl in einer Windows-PowerShell ausgef\u00FChrt werden:\u00A0Wie erwartet sind noch keine FHIR-Ressourcen in Blaze vorhanden. Nachdem CentraXX wieder gestartet ist, sollten bei einer erfolgreichen Konfiguration Eintr\u00E4ge zum Export im Serverlog erhalten werden. Als Beispiel werden die Eintr\u00E4ge f\u00FCr einen Export eines CentraXX-Patienten aufgef\u00FChrt:2021-01-14 20:25:01,503 INFO [de.kairos.centraxx.timer.NfnExportScheduler] (cxxScheduledTask-19) Select CXX EntityType 'PATIENT_MASTER' transform by template 'vitalstatus' export to FHIR resource 'Observation'2021-01-14 20:25:01,565 INFO [de.kairos.centraxx.fhir.r4.nfn.NfnExportManager] (cxxScheduledTask-19) Export bundle with '3' resources to target system 'http://localhost:8080/fhir'2021-01-14 20:25:01,568 INFO [de.kairos.centraxx.fhir.r4.nfn.NfnClient] (cxxScheduledTask-19) Cxx POST request: http://localhost:8080/fhir2021-01-14 20:25:01,608 INFO [de.kairos.centraxx.fhir.r4.nfn.NfnClient] (cxxScheduledTask-19) Cxx response: 200 F\u00FCr diesen Test sind in CentraXX genau drei Patienten vorhanden. Es existieren noch weitere Entit\u00E4ten, welche exportiert wurden. Eine erneute Abfrage der Anzahl von FHIR-Ressourcen in Blaze ergibt das folgende Ergebnis:Ausleitung ins DateisystemDie aus dem Transformations-Vorgang entsprungenen FHIR-Ressourcen k\u00F6nnen in Form von JSON-Dateien in das lokales Dateisystem ausgeleitet werden. Dazu m\u00FCssen verschiedene Konfigurationen in der ProjectConfig.json vorgenommen werden. Der Export muss aktiviert und ein Zielverzeichnis festgelegt werden. Dieses Zielverzeichnis wird neu angelegt, im Falle, dass es nicht bereits existiert:&quot;exportToFileSystem&quot;: {  &quot;description&quot;: &quot;If true, the scheduler will export to the specified file system exportFolder.&quot;,  &quot;value&quot;: true},&quot;exportFolder&quot;: {  &quot;value&quot;: &quot;C:/applications/centraxx-home/fhir-custom-export/test-export&quot;},Dar\u00FCber hinaus relevante Konfiguration wie &quot;patientFilterType&quot;, &quot;patientFilterValue&quot;,\u00A0&quot;exportInterval&quot; sind, wie oben beschrieben, vorgenommen worden.Nach Neustart von CentraXX werden die JSON-Dateien im angegebenen Verzeichnis angezeigt:AnhangBeispiel f\u00FCr ausgeleitetes FHIR-Bundle f\u00FCr die FHIR-Ressource &quot;Patient&quot;{  &quot;resourceType&quot;: &quot;Bundle&quot;,  &quot;type&quot;: &quot;transaction&quot;,  &quot;total&quot;: 3,  &quot;entry&quot;: [ {    &quot;fullUrl&quot;: &quot;Patient/1&quot;,    &quot;resource&quot;: {      &quot;resourceType&quot;: &quot;Patient&quot;,      &quot;id&quot;: &quot;1&quot;,      &quot;meta&quot;: {        &quot;versionId&quot;: &quot;EXAMPLE-ID&quot;,        &quot;profile&quot;: [ &quot;http://dktk.dkfz.de/fhir/StructureDefinition/onco-core-Patient-Pseudonym&quot; ],        &quot;security&quot;: [ {          &quot;system&quot;: &quot;http://terminology.hl7.org/CodeSystem/v3-Confidentiality&quot;,          &quot;code&quot;: &quot;U&quot;        } ]      },      &quot;identifier&quot;: [ {        &quot;type&quot;: {          &quot;coding&quot;: [ {            &quot;system&quot;: &quot;http://dktk.dkfz.de/fhir/onco/core/CodeSystem/PseudonymArtCS&quot;,            &quot;code&quot;: &quot;Global&quot;          } ]        },        &quot;value&quot;: &quot;DKTK-43134&quot;      } ],      &quot;gender&quot;: &quot;female&quot;,      &quot;birthDate&quot;: &quot;2020-01-01&quot;    },    &quot;request&quot;: {      &quot;method&quot;: &quot;PUT&quot;,      &quot;url&quot;: &quot;Patient/1&quot;    }  }, {    &quot;fullUrl&quot;: &quot;Patient/2&quot;,    &quot;resource&quot;: {      &quot;resourceType&quot;: &quot;Patient&quot;,      &quot;id&quot;: &quot;2&quot;,      &quot;meta&quot;: {        &quot;versionId&quot;: &quot;EXAMPLE-ID&quot;,        &quot;profile&quot;: [ &quot;http://dktk.dkfz.de/fhir/StructureDefinition/onco-core-Patient-Pseudonym&quot; ],        &quot;security&quot;: [ {          &quot;system&quot;: &quot;http://terminology.hl7.org/CodeSystem/v3-Confidentiality&quot;,          &quot;code&quot;: &quot;U&quot;        } ]      },      &quot;identifier&quot;: [ {        &quot;type&quot;: {          &quot;coding&quot;: [ {            &quot;system&quot;: &quot;http://dktk.dkfz.de/fhir/onco/core/CodeSystem/PseudonymArtCS&quot;,            &quot;code&quot;: &quot;Global&quot;          } ]        },        &quot;value&quot;: &quot;DKTK-98521&quot;      } ],      &quot;gender&quot;: &quot;male&quot;,      &quot;birthDate&quot;: &quot;1956-01-01&quot;    },    &quot;request&quot;: {      &quot;method&quot;: &quot;PUT&quot;,      &quot;url&quot;: &quot;Patient/2&quot;    }  }, {    &quot;fullUrl&quot;: &quot;Patient/11&quot;,    &quot;resource&quot;: {      &quot;resourceType&quot;: &quot;Patient&quot;,      &quot;id&quot;: &quot;11&quot;,      &quot;meta&quot;: {        &quot;versionId&quot;: &quot;EXAMPLE-ID&quot;,        &quot;profile&quot;: [ &quot;http://dktk.dkfz.de/fhir/StructureDefinition/onco-core-Patient-Pseudonym&quot; ],        &quot;security&quot;: [ {          &quot;system&quot;: &quot;http://terminology.hl7.org/CodeSystem/v3-Confidentiality&quot;,          &quot;code&quot;: &quot;U&quot;        } ]      },      &quot;identifier&quot;: [ {        &quot;type&quot;: {          &quot;coding&quot;: [ {            &quot;system&quot;: &quot;http://dktk.dkfz.de/fhir/onco/core/CodeSystem/PseudonymArtCS&quot;,            &quot;code&quot;: &quot;Global&quot;          } ]        },        &quot;value&quot;: &quot;DKTK-42313&quot;      } ],      &quot;gender&quot;: &quot;other&quot;,      &quot;birthDate&quot;: &quot;1993-01-01&quot;,      &quot;deceasedDateTime&quot;: &quot;2021-01-01&quot;    },    &quot;request&quot;: {      &quot;method&quot;: &quot;PUT&quot;,      &quot;url&quot;: &quot;Patient/11&quot;    }  } ]}", "tags": "", "url": "page64291632.html"},

]};
